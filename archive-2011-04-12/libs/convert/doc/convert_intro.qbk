[section:convert_intro Introduction]

/Boost.Convert/ builds on the past and present /boost::lexical_cast/ experience. Then /Boost.Convert/ takes those conversion-related ideas further to better suit today's applications and programming needs. Still, it offers simple, minimal interface, familiar conversion behavior and additionally provides:

* throwing and non-throwing conversion-failure behavior;
* support for the default\/fallback value to be returned when conversion fails;
* two types of the conversion-failure check - basic/simple and better\/safe;
* formatting support based on the standard /std::streams/ and /std::stream/-based manipulators (like /std::hex/, /std::scientific/, etc.);
* support for different locales;
* support for /boost::range/-compliant /char/ and /wchar_t/-based containers;
* no DefaultConstructibility requirement for the Target\/Destination type;
* consistent framework to uniformly incorporate any type-to-type conversions, extensibility and additional room to grow.

With its present support for string-to-type and type-to-string conversions it is an essential tool for applications making extensive
use of configuration or MS-Windows-Registry-style files or having to process/prepare considerable amounts of data in, say, XML, etc. More
so, it is easily extendible to accommodate, specialize and uniformly deploy new user-defined type-to-type conversions.

It needs to be mentioned though that /Boost.Convert/ is not an attempt to provide a full-blown parser or generator. For serious parsing tasks one might like to consider /Boost.Spirit/. Alternatively /Boost.Spirit/ might be deployed to write /Boost.Spirit/-based converter which then will be incorporated into the /Boost.Convert/ framework.

[endsect]
