[section Introduction]

['Boost.Convert] builds on the ['boost::lexical_cast] design and experience and takes those conversion\/transformation-related ideas further 

* to be applicable to a wider range of conversion-related deployment scenarios, 
* to provide a more flexible, extensible and configurable type-conversion framework. 

['Boost.Convert] has a modular design and what it can ultimately do is to a large extend defined by a pluggable ['converter] component. For example, one of the converters supplied with the proposal and discussed in the document is a ['std::stringstream]-based converter. With that converter deployed ['Boost.Convert] provides:

* string-to-type and type-to-string conversions;
* formatting support based on standard manipulators (like /std::hex/, /std::scientific/, etc.);
* support for different locales;
* /char/ and /wchar_t/ support;
* flexible throwing and non-throwing failed-conversion behavior;
* support for the fallback value to be returned when conversion\/transformation fails;
* two types of the conversion-failure check - quick/simple and generic;
* means to deploy types that do no meet the ['Default Constructibility] requirement;
* support for standard algorithms.

For example, the following snippet converts an array of strings representing hexadecimal numbers to integers and assigns INT_MAX to those which fail to convert:

 boost::array<char const*, 5> strings = {{ "0XF", "0X10", "0X11", "0X12", "not int" }};
 std::vector<int>            integers;
 boost::cstringstream_converter   cnv; // stringstream-based char converter

 std::transform(
    strings.begin(),
    strings.end(),
    std::back_inserter(integers),
    convert<int>::from<string>(ccnv(std::hex)).value_or(INT_MAX));

[*Please note that the described framework is not part of the Boost library collection even though in this document it is referred to as ['Boost.Convert]. It is done so in preparation for potential submission of the library to ['Boost].]

[endsect]
