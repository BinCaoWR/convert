[section Introduction]

[*Please note that the described framework is not part of the Boost library collection even though in this document it is referred to as ['Boost.Convert]. This is done in preparation for potential submission of the library to ['Boost].]

['Boost.Convert] builds on the ['boost::lexical_cast] design and experience and takes those conversion\/transformation-related ideas further 

* to be applicable to a wider range of conversion-related deployment scenarios, 
* to provide a more flexible, extensible and configurable type-conversion framework. 

The ['boost::lexical_cast] framework essentially consists of:

* an API facade to deploy the relevant functionality uniformly and 
* the means to plug a particular type in to the ['boost::lexical_cast] framework; namely, ['operator>>(std::istream&)] and ['operator<<(std::ostream&)]).

['Boost.Convert] follows that successful design and also consists of two components:

* the API facade to provide simple, minimal and uniform deployment interface;
* the extendible library of pluggable converters.

The API facade implements new and familiar conversion\/transformation-related behavior such as:

* flexible throwing, delayed-throwing and non-throwing failed-conversion behavior;
* support for the fallback value to be returned when conversion\/transformation fails;
* two types of the conversion-failure check - quick/simple and generic;
* means to deploy types that do no meet the ['Default Constructibility] requirement;
* support for standard algorithms.

The library of pluggable converters is independent of the ['Boost.Convert] API facade and is designed to be extended over time. With the current proposal three proof-of-the-concept converters are supplied -- string-to-type (and type-to-string) ['boost::lexical_cast]-based, ['scanf]-based and ['std::stringstream]-based converters. 

The  ['scanf]-based and ['boost::lexical_cast]-based converters demonstrate how existing and independent conversion facilities might be incorporated in to the ['Boost.Convert] framework.

The ['std::stringstream]-based converter draws on the standard ['std::streams] functionality and provides:

* string-to-type and type-to-string conversions;
* formatting support based on standard manipulators (like /std::hex/, /std::scientific/, etc.);
* support for different locales;
* /char/ and /wchar_t/ support.

For example, the following snippet converts an array of integers from their textual hexadecimal represention and assigns INT_MAX to those which fail to convert:

 boost::array<char const*, 5> strings = {{ "0XF", "0X10", "0X11", "0X12", "not int" }};
 std::vector<int>            integers;
 boost::cstringstream_converter   cnv; // stringstream-based char converter

 std::transform(
    strings.begin(),
    strings.end(),
    std::back_inserter(integers),
    convert<int>::from<string>(ccnv(std::hex)).value_or(INT_MAX));

An interesting (yet to be explored) feature is that ['Boost.Convert] is not limited to string-to-type and type-to-string conversions. In fact, the ['Boost.Convert] API facade is type-agnostic. The plugged-in converter ultimately dictates what types and conversions are supported. Consequently, a wide range of conversion\/transformation-related tasks can be addressed and deployed ['uniformly] by plugging-in special-purpose converters. For example, encryption by a string-to-string encrypting converter, etc.

[endsect]
