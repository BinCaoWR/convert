[section Getting Serious]

 int i2 = convert<int>::from("not an int", cnv).value_or(-1); // after the call i2 == -1

 if (i2 == -1) failed to convert

The code above is sufficiently straightforward. A limitation though is that it is not entirely deterministic as -1 might be the result of a conversion failure or the successful conversion of the "-1" string. Still, with "spare" values available outside the valid\/sensible range to indicate conversion failures such deployment might be adequate without introducing the above-mentioned behavioral non-determinism. Alternatively, it might be not that uncommon for applications to ignore conversion failures altogether and to simply proceed with the supplied fallback value.

Applications outside these mentioned categories still require a conversion failure reliably detected and processed accordingly. The `boost::lexical_cast`'s answer to the problem is to throw on failure and ['Boost.Convert] supports that behavior as well: 

 try
 {
     int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
     int i2 = boost::convert<int>::from(str, cnv).value(); // Throws if the conversion fails
     ...
 }
 catch (...)
 {
     // Handle failed conversion
 }

However, to cater for a wider range of program-flow variations, ['Boost.Convert] adds the flexibility of 

* delaying the moment when the conversion-failure exception is actually thrown or 
* avoiding the exception altogether. 

 convert<int>::result r1 = convert<int>::from(str1, cnv); // Does not throw on conversion failure
 convert<int>::result r2 = convert<int>::from(str2, cnv); // Does not throw on conversion failure

 ...

 try // Delayed processing of potential exceptions
 {
     int i1 = r1.value(); // Will throw if conversion failed
     int i2 = r2.value(); // Will throw if conversion failed
 }
 catch (...)
 {
     // Handle failed conversion
 }

 // Exceptions are avoided altogether
 int i1 = r1 ? r1.value() : fallback_value;
 int i2 = r2.value_or(fallback_value);
 int i3 = convert<int>::from(str3, cnv).value_or(fallback_value);

Here `convert<T>::result` steps forward as the actual type returned by `convert<T>::from` which until now we avoided by immediately calling its value-accessor methods:

 int i1 = convert<int>::from(str1, cnv).value();
 int i2 = convert<int>::from(str2, cnv).value_or(fallback_value);

Both `boost::lexical_cast` and `convert<T>::result` behavior reflect the fact that a conversion request is only a ['request] which may succeed but also may fail. However, from the user perspective `boost::lexical_cast` processes failure in a somewhat harsh and non-negotiable manner.  `convert<T>::result` takes a softer approach and leaves the decision to the user. In my personal experience the choice has overwhelmingly been to avoid exceptions altogether with program flows similar to:

 convert<int>::result r1 = convert<int>::from(str1, cnv);
 convert<int>::result r2 = convert<int>::from(str2, cnv);

 if (!r1) log("str1 conversion failed");
 if (!r2) log("str2 conversion failed");

 int i1 = r1 ? r1.value() : 5;
 int i2 = r2.value_or(6);

 ...proceed

[note `convert<T>::result` is a temporary and transient type and is to be replaced with `tr1::optional<T>` which actually provides all the necessary functionality and interface.]

[endsect]
