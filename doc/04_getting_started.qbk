[section:convert_started Getting Started]

In its simplest form the conversion functionality might be deployed as follows:

 #include <boost/convert/api.hpp>
 #include <boost/convert/sstream_converter.hpp>

 using boost::convert;

 boost::cstringstream_converter cnv; // stringstream-based char converter

 int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
 int i2 = convert<int>::from(str, cnv).value(); // Throws if the conversion fails
 int i3 = convert<int>::from(str, cnv).value_or(-1); // Returns -1 if the conversion fails

These calls can be translated to plain English as "['Convert a string to int]" for ['i1] and ['i2] and "['Convert a string to int and return -1 if the conversion fails]" for ['i3]. 

The ['i1] and ['i2] deployments look sufficiently close and, in fact, are identical behaviorally. Namely, if the requested conversion fails, an exception is thrown. It is due to the fact that the user request -- "['Convert a string to int]" -- lacks the specification for the failure use-case. Consequently, ['boost::lexical_cast] and ['boost::convert] take the liberty of handling that not-mentioned use-case in the standard way.

The second specification -- "['Convert a string to int and return -1 if the conversion fails]" -- is complete and processed "as ordered" with the provided fallback value returned if the requested conversion fails. 

The described (very basic) interface might be sufficient for a variety of conversion deployments. For example:

 boost::cstringstream_converter ccnv; // stringstream-based char converter

 int num_threads = convert<int>::from(str1, ccnv(std::hex)).value_or(INT_MAX); // Read as hex
 int num_windows = convert<int>::from(str2, ccnv(std::dec)).value_or(INT_MAX); // Read as decimal

 if (num_threads == INT_MAX) log("bad num_threads"), num_threads = default_num_threads;
 if (num_windows == INT_MAX) log("bad num_windows"), num_windows = default_num_windows;

 ... proceed

Or even shorter, if we do not care logging:

 int num_threads = convert<int>::from(str1, ccnv(std::hex)).value_or(default_num_threads); // Read as hex
 int num_windows = convert<int>::from(str2, ccnv(std::dec)).value_or(default_num_windows); // Read as decimal

 ... proceed

So far the deployment of ['boost::convert] seems more compact and natural (your mileage may vary) and might be potentially more efficient compared to ['boost::lexical_cast] deployment which achieves a similar (excluding formatting) result with something like

 int num_threads;

 try
 {
     num_threads = lexical_cast<int>(str);
 }
 catch (...)
 {
     log("bad num_threads");
     num_threads = default_num_threads;
 }

This is by-design ['boost::lexical_cast]'s only behavior. Simple, straigtforward and comprehensible. Unfortunately, it makes quite a few legitimate process flows difficult\/awkward to implement. That is the niche that ['boost::convert] is trying to fill.

[endsect]
