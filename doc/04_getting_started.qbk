[section Getting Started]

[note Given the ubiquity of and the familiarity of the programming community with `boost::lexical_cast`, here and further in the documentation `boost::lexical_cast` is often mentioned as a reference.]

In its simplest form the ['Boost.Convert] functionality might be deployed as follows:

 #include <boost/convert/api.hpp>
 #include <boost/convert/converter/sstream.hpp>

 using boost::convert;

 boost::cstringstream_converter cnv; // stringstream-based char converter

 int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
 int i2 = convert<int>::from(str, cnv).value(); // Throws if the conversion fails
 int i3 = convert<int>::from(str, cnv).value_or(-1); // Returns -1 if the conversion fails

The above calls can be interpreted as "['Convert a string to int]" for `i1` and `i2` and "['Convert a string to int and return -1 if the conversion fails]" for `i3`. 

The `i1` and `i2` deployments look sufficiently close and, in fact, are identical behaviorally. Namely, if the requested conversion fails, an exception is thrown. The user request -- "['Convert a string to int]" -- lacks the specification for the failure use-case. Consequently, `boost::lexical_cast` and `boost::convert` resort to handling that not-mentioned use-case in the standard way.

The second specification -- "['Convert a string to int and return -1 if the conversion fails]" -- is complete and processed "as ordered" with the provided fallback value returned if the requested conversion fails. 

The described (very basic) interface might be sufficient for a variety of conversion deployments. For example:

 boost::cstringstream_converter ccnv; // stringstream-based char converter

 int num_threads = convert<int>::from(str1, ccnv(std::hex)).value_or(INT_MAX); // Read as hex
 int num_windows = convert<int>::from(str2, ccnv(std::dec)).value_or(INT_MAX); // Read as decimal

 if (num_threads == INT_MAX) log("bad num_threads"), num_threads = default_num_threads;
 if (num_windows == INT_MAX) log("bad num_windows"), num_windows = default_num_windows;

 ... proceed

Or even shorter, if we do not care logging:

 int num_threads = convert<int>::from(str1, ccnv(std::hex)).value_or(default_num_threads); // Read as hex
 int num_windows = convert<int>::from(str2, ccnv(std::dec)).value_or(default_num_windows); // Read as decimal

 ... proceed

So far the deployment of `boost::convert` seems more compact and natural (your mileage may vary) and might be potentially more efficient compared to `boost::lexical_cast` deployment which achieves a similar (excluding `std::hex` and `std::dec` formatting) result with something like

 int num_threads;

 try
 {
     num_threads = lexical_cast<int>(str);
 }
 catch (...)
 {
     log("bad num_threads");
     num_threads = default_num_threads;
 }

By design this is `boost::lexical_cast`'s only behavior. Fairly straightforward and comprehesible. Unfortunately, it makes quite a few legitimate process\/program flows difficult and awkward to implement. That is the niche that ['Boost.Convert] is trying to fill.

[endsect]
