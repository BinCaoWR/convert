[section:convert_getting_serious Getting Serious]

 int i2 = convert<int>::from("not an int", cnv).value_or(-1); // after the call i2 = -1

 if (i2 == -1) failed to convert

The code above is sufficiently straightforward. A wrinkle though is that it is not entirely generic and deterministic as -1 might be the result of a conversion failure or the successful conversion of the "-1" string. Still, with "spare" values available outside the valid\/sensible range to indicate conversion failures (say, INT_MAX for integers), such deployment might be quite adequate without introducing the above-mentioned behavioral non-determinism. More so, it might be not that uncommon for applications to ignore conversion failures altogether and to simply proceed with the supplied fallback value.

Applications outside these mentioned categories still require a conversion failure reliably detected and processed accordingly. The ['boost::lexical_cast]'s answer to the problem is to throw on failure and ['boost::convert] supports that behavior as well: 

 try
 {
     int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
     int i2 = boost::convert<int>(str, cnv).value(); // Throws if the conversion fails
     ...
 }
 catch (...)
 {
     Conversion failed
 }

However, to cater for a wider range of deployment use-cases ['boost::convert] adds the flexibility of 

* delaying the moment when the conversion-failure exception is thrown or 
* avoiding the exception altogether. 

 convert::<int>result r1 = boost::convert<int>(str1, cnv); // Does not throw on conversion failure
 convert::<int>result r2 = boost::convert<int>(str2, cnv); // Does not throw on conversion failure

 try // Processing of potential exceptions delayed
 {
     int i1 = r1.value(); // Will throw if conversion failed
     int i2 = r2.value(); // Will throw if conversion failed
 }
 catch (...)
 {
     Conversion failed
 }

 // Exceptions are avoided altogether
 int i1 = r1 ? r1.value() : fallback_value;
 int i2 = r2 ? r2.value() : fallback_value;
 int i3 = boost::convert<int>(str3, cnv).value_or(fallback_value);

Here ['convert<T>::result] steps forward as the actual type returned by ['convert<T>::from] which until now we avoided by immediately calling its value-accessor methods:

 int i1 = boost::convert<int>(str1, cnv).value();
 int i2 = boost::convert<int>(str2, cnv).value_or(fallback_value);

Both ['boost::lexical_cast] and ['convert<T>::result] underscore the fact that a conversion request is only a ['request] which may succeed but is also may fail. However, from the user perspective ['boost::lexical_cast] processes failure in a somewhat harsh and non-negotiable manner.  ['convert<T>::result] chooses a softer approach and leaves the decision to the user. In my personal experience the choice has overwhelmingly been to avoid exceptions altogether with process-flow variations similar to:

 convert<int>::result r1 = boost::convert<int>(str1, cnv);
 convert<int>::result r2 = boost::convert<int>(str2, cnv);

 if (!r1) log("str1 conversion failed");
 if (!r2) log("str2 conversion failed");

 int i1 = r1 ? r1.value() : 5;
 int i2 = r2.value_or(6);

 ...proceed

[*Please note:] ['convert<T>::result] is a temporary\/transient type and is to be replaced with ['tr1::optional<T>] which actually provides all the necessary functionality and interface.

[endsect]
