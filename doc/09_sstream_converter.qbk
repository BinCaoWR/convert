[section std::stringstream-Based Converter]

[*Please note:] ['the converter is currently a work-in-progress. Suggestions are most welcomed. Changes are to be expected.]

The converter is deployed with

 #include <boost/convert/converter/sstream.hpp>

Its purpose is to provide conversion-related formatting and locale support not present in ['boost::lexical_cast]. Advantages of a ['std::stream]-based engine are 

* availability and maturity;
* formatting and locale support;
* familiar interface and deployment;
* instant re-use of available standard manipulators (['std::hex], etc.);
* extendibility (via custom manipulators (see [link 1 \[1\]])).

[section Formatting Support]

Formatting support is provided by the underlying ['std::stringstream]. Consequently, the API heavily borrows formatting metaphors from this underlying component. One such metaphor is the ['manipulator] represented by ['std::hex], ['std::dec], ['std::uppercase], ['std::scientific], etc.

The following code demonstrates how the converter is configured on-the-fly to read ['char] and ['wchar_t] strings in the ['std::hex] or ['std::dec] format:

 using boost::convert;

 boost::cstringstream_converter ccnv; // stringstream-based char converter
 boost::wstringstream_converter wcnv; // stringstream-based wchar_t converter

 // int v00 = boost::lexical_cast<int>("FF"); // Fails. Throws.
 int v01 = convert<int>::from("FF", ccnv(std::hex)).value_or(0);
 int v02 = convert<int>::from(L"F", wcnv(std::hex)).value_or(0);
 int v03 = convert<int>::from("FF", ccnv(std::dec)).value_or(-5);
 int v04 = convert<int>::from(L"F", wcnv(std::dec)).value_or(-5);

 BOOST_ASSERT(v01 == 255); // "FF"
 BOOST_ASSERT(v02 ==  15); // L"F"
 BOOST_ASSERT(v03 ==  -5); // Failed to convert "FF" as decimal.
 BOOST_ASSERT(v04 ==  -5); // Failed to convert L"F" as decimal.

For batch-processing it might be more efficient to configure the converter once:

 ccnv(std::showbase)(std::uppercase)(std::hex);

 BOOST_ASSERT(convert<string>::from(255, ccnv).value() == "0XFF");
 BOOST_ASSERT(convert<string>::from( 15, ccnv).value() ==  "0XF");

An alternative (more generic) formatting interface is being extended and explored:

 namespace cnv = boost::conversion;
 namespace arg = boost::conversion::parameter;
 
 ccnv(arg::base = cnv::base::dec)
     (arg::uppercase = false)
     (arg::notation = cnv::notation::scientific);
 
which is equivalent to the following ['manipulator]-based variant:
 
 ccnv(std::dec)(std::nouppercase)(std::scientific);
 
[endsect]
[section Locale Support]

Locale support is similar to the formatting support as demonstrated by the following example (the Linux version):

 #include <boost/convert/converter/sstream.hpp>

 using boost::convert;

 boost::cstringstream_converter ccnv; // stringstream-based char converter

 char const*   double_str = "1.2345E-02"; // Upper-case. Separated by a dot.
 char const* eng_expected = "1.235e-02";  // Lower-case. Separated by a dot. Lower precision.
 char const* rus_expected = "1,235e-02";  // Lower-case. Separated by a comma. Lower precision.
 std::locale   rus_locale;
 std::locale   eng_locale;

 try
 {
    rus_locale = std::locale("ru_RU.UTF-8");
    eng_locale = std::locale("");
 }
 catch (...)
 {
    printf("Bad locale.\n");
    exit(1);
 }

 // Specification of the expected format.
 ccnv(std::setprecision(4))(std::scientific)(std::uppercase);

 // Convert the original string to binary double.
 double double_v = convert<double>::from(double_str, ccnv).value();

 // Change the format to lower precision and to lower case.
 ccnv(std::setprecision(3))(std::nouppercase);

 // Convert the double back to Russian- and English-locale strings.
 string double_rus = convert<string>::from(double_v, ccnv(rus_locale)).value();
 string double_eng = convert<string>::from(double_v, ccnv(eng_locale)).value();

 BOOST_ASSERT(double_rus == rus_expected);
 BOOST_ASSERT(double_eng == eng_expected);

[endsect]
[section Integration of User-Defined Types]

As the converter uses ['std::stringstream] to do actual conversions it carries over the ['std::stringstream]-imposed requirements (as ['boost::lexical_cast] does):

* ['TypeIn] needs to be ['Output Streamable];
* ['TypeOut] needs to be ['Input Streamable]; 

In practical terms the mechanism for integrating a user-defined type into the ['Boost.Convert] framework (for deployment with this described ['std::stringstream]-based converter) is the same as for ['boost::lexical_cast]. That is, the respective type needs to have the following operators defined:

 std::istream& operator>>(std::istream&, TypeOut&);
 std::ostream& operator<<(std::ostream&, TypeIn const&);

For example,

 struct change
 {
     enum value_type { no, up, dn };

     change(value_type v =no) : value_(v) {}

     friend std::istream& operator>>(std::istream&, change&)
     friend std::ostream& operator<<(std::ostream&, change const&);
    
     private: value_type value_;
 };
 std::istream& operator>>(std::istream& stream, change& dir)
 {
     string str;
     stream >> str;
     /**/ if (str == "up") dir.value_ = up;
     else if (str == "dn") dir.value_ = dn;
     else if (str == "no") dir.value_ = no;
     else stream.setstate(std::ios_base::failbit);

     return stream;
 }
 std::ostream& operator<<(std::ostream& stream, change const& dir)
 {
     return stream << (dir.value_ == up ? "up" : dir.value_ == dn ? "dn" : "no");
 }

That allows handling conversions of user-defined types with plugged-in ['std::stringstream]-based converter:

 using boost::convert;

 boost::cstringstream_converter cnv; // stringstream-based char converter

 int i = convert<int>::from(str, cnv).value();
 change c = convert<change>::from(str, cnv).value();

[endsect]
[endsect]
