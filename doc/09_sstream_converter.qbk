[section ['std::stringstream]-Based Converter]

[*Please note:] ['the converter is currently a work-in-progress. Suggestions are most welcomed. Changes are to be expected.]

The converter is deployed with

 #include <boost/convert/sstream_converter.hpp>

The purpose of this converter is to provide conversion-related formatting and locale support which are not present in ['boost::lexical_cast]. Advantages of a ['std::stream]-based formatting engine are 

* the familiar interface and deployment;
* instant re-use of available standard manipulators (['std::hex], etc.);
* extendibility (if one is familiar writing custom manipulators (see __ref_4__));
* locale support. 

[section Formatting Support]

Formatting support is provided by the underlying ['std::stringstream]. Consequently, ['sstream_converter] API heavily borrows formatting metaphors from this underlying component. One such metaphor is the ['manipulator] represented by ['std::hex], ['std::dec], ['std::uppercase], ['std::scientific], etc.

The following code demonstrates how the converter is configured on-the-fly to read ['char] and ['wchar_t] strings in the ['std::hex] or ['std::dec] format:

 using boost::convert;

 boost::cstringstream_converter ccnv; // stringstream-based char converter
 boost::wstringstream_converter wcnv; // stringstream-based wchar_t converter

 // int v00 = boost::lexical_cast<int>("FF"); // Fails. Throws.
 int v01 = convert<int>::from("FF", ccnv(std::hex)).value_or(0);
 int v02 = convert<int>::from(L"F", wcnv(std::hex)).value_or(0);
 int v03 = convert<int>::from("FF", ccnv(std::dec)).value_or(-5);
 int v04 = convert<int>::from(L"F", wcnv(std::dec)).value_or(-5);

 BOOST_ASSERT(v01 == 255); // "FF"
 BOOST_ASSERT(v02 ==  15); // L"F"
 BOOST_ASSERT(v03 ==  -5);
 BOOST_ASSERT(v04 ==  -5);

For batch-processing it might be more efficient to configure the converter once and then re-use it:

 ccnv(std::showbase)(std::uppercase)(std::hex);

 BOOST_ASSERT(convert<string>::from(255, ccnv).value() == "0XFF");
 BOOST_ASSERT(convert<string>::from( 15, ccnv).value() ==  "0XF");

[endsect]

[section Locale Support]

Locale support is similar to the formatting support as demonstrated by the following example (the Linux version):

 #include <boost/convert/sstream_converter.hpp>

 using boost::convert;

 boost::cstringstream_converter ccnv; // stringstream-based char converter

 char const*   double_str = "1.2345E-02"; // Upper-case. Separated by a dot.
 char const* eng_expected = "1.235e-02";  // Lower-case. Separated by a dot. Lower precision.
 char const* rus_expected = "1,235e-02";  // Lower-case. Separated by a comma. Lower precision.
 std::locale   rus_locale;
 std::locale   eng_locale;

 try
 {
    rus_locale = std::locale("ru_RU.UTF-8");
    eng_locale = std::locale("");
 }
 catch (...)
 {
    printf("Bad locale.\n");
    exit(1);
 }

 ccnv(std::setprecision(4))(std::scientific)(std::uppercase);

 // Convert the original string to binary double.
 double double_v = convert<double>::from(double_s01, ccnv).value();

 // Change to lower precision and to lower case.
 ccnv(std::setprecision(3))(std::nouppercase);

 // Convert the double back to Russian- and English-locale strings.
 string double_rus = convert<string>::from(double_v, ccnv(rus_locale)).value();
 string double_eng = convert<string>::from(double_v, ccnv(eng_locale)).value();

 BOOST_ASSERT(double_rus == rus_expected);
 BOOST_ASSERT(double_eng == eng_expected);

[endsect]
[section Integration of User-Defined Types]

As the converter uses ['std::stringstream] to do actual conversions it carries over the ['std::stringstream]-imposed requirements (as ['boost::lexical_cast] does):

* ['TypeIn] needs to be ['Output Streamable];
* ['TypeOut] needs to be ['Input Streamable]; 

In practical terms the mechanism for integrating a user-defined type into the ['Boost.Convert] framework (for deployment with this described ['std::stringstream]-based converter) is the same as for ['boost::lexical_cast]. That is, the respective type needs to have following operators defined:

 std::istream& operator>>(std::istream&, TypeOut&);
 std::ostream& operator<<(std::ostream&, TypeIn const&);

For example,

 struct direction
 {
     enum value_type { no, up, dn };

     direction(value_type v =no) : value_(v) {}

     friend std::istream& operator>>(std::istream&, direction&)
     friend std::ostream& operator<<(std::ostream&, direction const&);
    
     private: value_type value_;
 };
 std::istream& operator>>(std::istream& stream, direction& dir)
 {
     string str;
     stream >> str;
     /**/ if (str == "up") dir.value_ = up;
     else if (str == "dn") dir.value_ = dn;
     else if (str == "no") dir.value_ = no;
     else stream.setstate(std::ios_base::failbit);

     return stream;
 }
 std::ostream& operator<<(std::ostream& stream, direction const& dir)
 {
     return stream << (dir.value_ == up ? "up" : dir.value_ == dn ? "dn" : "no");
 }

That allows handling conversions of user-defined types uniformly via the ['boost::convert] interface:

 using boost::convert;

 boost::cstringstream_converter cnv; // stringstream-based char converter

 int i = convert<int>::from(str, cnv).value();
 direction d = convert<direction>::from(str, cnv).value();

[endsect]
[section Performance]

This described converter provides ['string-to-type] and ['type-to-string] conversions as ['boost::lexical_cast] does. However, the priorities of these mentioned converters are quite different. For basic (['int], etc.) types ['boost::lexical_cast] performance has been optimized quite dramatically (see __ref_5__). Therefore, if speed is your primary objective and your needs do not go beyond basic types, then deploying ['boost::lexical_cast] (directly or via the ['Boost.Convert] framework) might be a better option. However, for user-defined types it appears to be quite a different story.

 boost::cstringstream_converter ccnv; // stringstream-based char converter
 int const num_cycles = 1000000;
 double p1 = clock();

 for (int k = 0; k < num_cycles; ++k)
    boost::lexical_cast<direction>("up");

 double p2 = clock();

 for (int k = 0; k < num_cycles; ++k)
    boost::convert<direction>::from("up", ccnv).value();

 double p3 = clock();

 printf("convert=/lcast=%.2f/%.2f seconds\n", (p3 - p2) / CLOCKS_PER_SEC, (p2 - p1) / CLOCKS_PER_SEC);

Performance was tested for a user-defined ['direction] type with the code above. On a Linux box ['boost::convert] performed twice as fast compared to ['boost::lexical_cast] v1.54 producing the following output:

 convert/lcast=0.25/0.52 seconds.

Unfortunately but unavoidably the test is not exactly fair due to different underlying designs.

The standard ['Boost.Convert] usage pattern is to create a converter or converters once and then re-use them (as in the code above). Consequently, performance-wise this deployment pattern is likely to represent the fourth (['std::stringstream without construction]) column of the __ref_5__ table. 

In turn, ['boost::lexical_cast] also deploys the standard ['stream] framework for user-defined types. However, due to its design ['boost::lexical_cast] creates and then destroys an instance of a stream type for every function call and, consequently, probably takes the third (['std::stringstream with construction]) and much slower column of the __ref_5__ table. 

[endsect]
[endsect]

