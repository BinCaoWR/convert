[section Type Requirements]

In order for a user-defined type to be integrated into the `boost::lexical_cast` framework (at least until 1.47; see [@http://www.boost.org/doc/libs/1_47_0/libs/conversion/lexical_cast.htm `boost::lexical_cast` 1.47 documentation]):

* ['TypeOut] needs to be ['Copy Constructible];
* ['TypeOut] needs to be ['Default Constructible];
* ['TypeOut] needs to be ['Input Streamable];
* ['TypeIn] needs to be ['Output Streamable].

The first two requirements are imposed by the `boost::lexical_cast` design and implementation and the last two requirements by the underlying `std::stringstream` engine.

In turn, the ['Boost.Convert] API facade has the following requirements:

* ['TypeOut] needs to be ['Copy Constructible];
* ['TypeOut] needs to be ['Default Constructible] by ['default].

Additional requirements might be imposed by the respective converter. For example, both mentioned -- `boost::lexical_cast`-based and `std::stringstream`-based -- converters require

* ['TypeIn] to be ['Output Streamable];
* ['TypeOut] to be ['Input Streamable].

[endsect]
[section The ['Default Constructible] Type Requirement]

(Not too) deeply in the bowels of the implementation a temporary-storage instance of the ['TypeOut] type is created and then populated with the conversion result. The `boost::lexical_cast` implementation chooses the default constructor to create such an instance. Consequently, the ['TypeOut] type needs to be ['Default Constructible]. For more details see [@http://www.boost.org/doc/libs/1_55_0/doc/html/boost_lexical_cast.html `boost::lexical_cast` documentation]. 

['Boost.Convert] also creates a temporary-storage instance of the ['TypeOut] type that the respective converter then populates with the conversion result. By default that temporary-storage is created with

 namespace boost
 {
    template<class TypeOut> 
    TypeOut 
    convert<TypeOut>::create_storage() 
    { 
        return TypeOut(); 
    }
 }

and, therefore, the ['Default Constructible] requirement is also the ['default] requirement of the ['Boost.Convert] framework. 

A well-designed type (in my opinion, anyway) should only have meaningful and unambiguous constructors... and the default constructor is not always and necessarily one of them. Consider the following as one such example:

 struct direction
 {
     enum value_type { up, dn };
     direction(value_type value) : value_(value) {}
     private: value_type value_;
 };

The `direction` type has no default state. It is not ['Default Constructible] and, consequently, the following calls do not compile:

 direction dir1 = lexical_cast<direction>(str); // Does not compile
 direction dir2 = convert<direction>::from(str).value(); // Does not compile

However, ['Boost.Convert] is able to handle such a type with little help from the user -- the instructions ['how] to create that mentioned temporary-storage:

 namespace boost
 {
    template<> inline direction convert<direction>::create_storage() 
    { 
        return direction(direction::up); 
    }
 }

 ...

 direction dir1 = lexical_cast<direction>(str); // Does not compile
 direction dir2 = convert<direction>::from(str).value(); // Compiles

[endsect]
