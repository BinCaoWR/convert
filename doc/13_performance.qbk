[section Performance]

The performance of ['Boost.Convert] entirely depends on the converter deployed. Several ['string-to-type] conversion facilities have been tested. Namely,

* the raw ['scanf()] function;
* ['boost::lexical_cast];
* ['Boost.Convert] with the ['std::stringstream]-based converter;
* ['Boost.Convert] with the ['scanf]-based converter.
* ['Boost.Convert] with the ['strtol]-based converter.

Performance was tested for string conversions to the ['integer] type and the user-defined ['direction] type (described later in the documentation). See the actual code in ['test/test_convert.cpp]. On Cygwin platform compiled with gcc 4.8.2 I had the following results:

 $ g++ -O0 test_convert.cpp -I../..
 string-to-user-defined type: lcast/convert=6.09/4.59 seconds.
 string-to-int: scanf/lcast=1.09/1.77. converters sstream/scanf/mixed=2.67/1.19/0.42 seconds.

 $ g++ -O3 test_convert.cpp -I../..
 string-to-user-defined type: lcast/convert=5.47/4.16 seconds.
 string-to-int: scanf/lcast=1.06/1.19. converters sstream/scanf/mixed=2.36/1.08/0.28 seconds.

That same code compiled with MS Visual C++ 2010 Express showed greater differences when compiled non-optimized and optimized-for-speed:

 Not optimized:
 string-to-user-defined type: lcast/convert=18.98/14.25 seconds.
 string-to-int: scanf/lcast=3.05/1.22. converters sstream/scanf/mixed=24.14/6.39/1.23 seconds.

 Optimized for speed:
 string-to-user-defined type: lcast/convert=6.30/2.97 seconds.
 string-to-int: scanf/lcast=0.77/0.86. converters sstream/scanf/mixed=5.66/0.81/0.28 seconds.

That same code compiled on a Ubuntu box (compiled with gcc 4.6.3) produced the following result:

 ...

Non-optimized times are more of a curiosity -- to demonstrate (and to remind) that considerable performance is to be gained via optimized compilation. Optimized times are the ones to be seriously looked at and analyzed. They show that for something as basic as string-to-int the ['strtol]-based converter comes far ahead of the rest. ['scanf()] comes next (despite ['lexical_cast] performance table ([link 5 \[5\]]) claiming otherwise). Not surprisingly ['Boost.Convert] with the ['scanf]-based converter comes equal or close to ['scanf()]. Given type-safety and interface-related benefits provided by the ['Boost.Convert] framework it (with appropriate converters) should probably be the first choice for basic conversions.
 
For user-defined types only two converters were tested -- ['boost::lexical_cast] and ['Boost.Convert] with the ['std::stringstream]-based converter. Other conversion facilities did not provide that functionality.

Both converters provide ['string-to-type] and ['type-to-string] conversions. However, their priorities are quite different. For basic (['int], etc.) types ['boost::lexical_cast] performance has been optimized (see [link 5 \[5\]]). Therefore, if speed is your primary objective and your needs do not go beyond basic types, then deploying ['boost::lexical_cast] (directly or via the ['Boost.Convert] framework) might be an option to explore. However, for user-defined types it appears to be quite a different story with ['Boost.Convert] consistently outperforming ['boost::lexical_cast] in the tests.

These results probably reflect different underlying designs. The standard ['Boost.Convert] usage pattern is to create a converter or converters once and then re-use them (as in the code above). Consequently, performance-wise this deployment pattern is likely to represent the fourth (['std::stringstream without construction]) column of the [link 5 \[5\]] table. 

In turn, ['boost::lexical_cast] also deploys the standard ['stream] framework for user-defined types. However, due to its design ['boost::lexical_cast] creates and then destroys an instance of a stream type every time the function is called and, consequently, probably belongs with the third (['std::stringstream with construction]) and much slower column of the [link 5 \[5\]] table. 

[endsect]
