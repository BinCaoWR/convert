[section Design Notes]

Feel free to skip this section. It is here to document the process and the decisions made during design to be able to review and to reevaluate and to ensure the relevancy and the correctness of those decisions and ultimately the design. Still, this section might be useful to understand why certain decisions have been made and why ['Boost.Convert] is the way it is.

[section Requirements]

['Boost.Convert] has been designed to satisfy the following user requirements:

# ['(R10)] ['Boost.Convert] shall provide a mechanism and an interface that take a value of type ['TypeIn] and yield a value of type ['TypeOut] using an algorithm of type ['Converter];
# ['(R20)] ['Boost.Convert] shall provide a mechanism and an interface to indicate success or failure of the requested conversion;
# ['(R30)] ['Boost.Convert] shall provide fully-functional interfaces for two different program flows where
    # ['(R31)] error-processing is orthogonal to the normal program flow (exception-throwing interface);
    # ['(R32)] normal and error-processing flows are part of the same program flow (non-throwing interface);
# ['(R40)] The throwing interface shall return the result of successful conversion or shall throw an exception;
# ['(R50)] The non-throwing interface shall return the result and/or some indication of conversion success or failure;
    # ['(R51)] there shall be means to distinguish success from failure;
    # ['(R52)] the result of conversion shall only be available when conversion succeeds;
    # ['(R53)] when conversion fails, an optional fallback value shall be returned instead if supplied;
    # ['(R54)] in the case of failure (with no fallback provided) an attempt to retrieve the result shall result in an exception thrown;
# ['(R60)] Converters shall be independent of and shall not rely on the ['Boost.Convert] infrastructure.

[endsect]

[section Public/User Interface]
[section The Evolution of The Signature]

The first attempt to accommodate the User Requirements might result in the following fairly conventional interface:

 template<typename Out, typename In> Out  convert (In const&); //#1
 template<typename Out, typename In> Out  convert (In const&, Out const& fallback); //#2
 template<typename Out, typename In> bool convert (Out& result, In const&); //#3
 template<typename Out, typename In> bool convert (Out& result, In const&, Out const& fallback); //#4

with the following behavior:

# returns the result or throws on failure (['R31], ['R40]);
# does not throw, returns the result or the provided fallback (['R50], ['R53] but not ['R51]);
# does not throw, writes the result to `result` (when successful), returns indication of success or failure (['R50], ['R51] but not ['R53]);
# does not throw, writes the result to `result` (when successful) or the provided fallback, returns indication of success or failure (['R50], ['R53] and ['R51]).

The #3 and #4 signatures are special as they essentially return two things -- the actual result (written into the `result`) and the indication of success or failure (returned by the functions). Given that a reference to `result` is passed in, the actual `result` instance is constructed (storage allocated and initialized) outside the function calls. 

That leads to ['potential inefficiency] because the initialization part is wasteful regardless if conversion succeeds or fails -- the original initialization value is either overridden (with the result or the fallback) or meaningless. `boost::optional` has the unique property of being able to allocate storage ['without initializing it]. Consequently, to avoid the overhead of wasteful initialization, we might use it to our advantage and to change the signatures to
 
 bool convert (boost::optional<Out>&, In const&); //#3
 bool convert (boost::optional<Out>&, In const&, Out const&); //#4

or, given that the indication of success or failure is now encapsulated in `boost::optional<Out>`, even further to

 void convert (boost::optional<Out>&, In const&); //#3
 void convert (boost::optional<Out>&, In const&, Out const&); //#4

or expressed more idiomatically (in C++) as:

 boost::optional<Out> convert (In const&);
 boost::optional<Out> convert (In const&, Out const&);

So, after fixing #3 and #4 we have arrive to

 Out                  convert (In const&); //#1
 Out                  convert (In const&, Out const&); //#2
 boost::optional<Out> convert (In const&); //#3
 boost::optional<Out> convert (In const&, Out const&); //#4

which obviously does not work as #1 clashes with #3 and #2 clashes with #4. 

The good thing is that now #1 and #2 are not needed as they are duplicates of #3 and #4 deployments with `value()` applied to the to the `boost::optional` result:

 Out out1 = boost::convert(int); // #1 style deployment
 Out out2 = boost::convert(int).value(); // #3 style deployment

With #1 and #2 eliminated as duplicates (or syntactic sugar some might say) we are left with:

 boost::optional<Out> convert (In const&); //#3
 boost::optional<Out> convert (In const&, Out const&); //#4

Another good thing `boost::optional` is that it allows us to eliminate #4 as well:

The next obvious step is to eliminate #4 the same way #1 and #2 have been eliminated:

Out out = convert<Out>(in).value_or(def); //#3 deployment covering #4 interface

So, we arrive to one and only

//3. optional<Out> convert(In const &);

Does it make sense?

You might not like the outcome but you do see the logic behind the transformation of the interface, don't you?

 and too restrictive with regard to the ['Out] type.



[endsect]
[section Converter Pluggability]

On numerous occasions it was noted that converters might be deployed directly. What such deployment would be lacking and what the single `boost::convert()` user interface provides is ['uniform] deployment and ['consistent behavior]. One single interface advertises and enforces a certain "contract" between the user (service consumer) and ['varying] conversion facilities (service provider). Working off such a "contract" allows

* for easier management of parallel development of the components meant to interact or rely on each other; 
* to adjust to requirement changes without major existing-code disruption (that includes major re-writes, major re-testing, etc.);
* easier deployment in generic code.

[endsect]
[section Converter-parameter-related considerations (explicit, default, globally-set, others)]
[endsect]
[section The Perceived Potential Complexity of the Interface]

The interface might be perceived as complex due to it trying to cater for different process flows and wide variety of deployment patterns. 

[endsect]
[endsect]

[section Converter Signature]
[endsect]
[endsect]

