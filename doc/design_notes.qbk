[section Design Notes]

Feel free to skip this section. It is here to document the process and the decisions made during design to be able to review and to reevaluate and to ensure the relevancy and the correctness of those decisions and ultimately the design. Still, this section might be useful to understand why certain decisions have been made and why ['Boost.Convert] is the way it is.

[section Requirements]

['Boost.Convert] has been designed to satisfy the following user requirements:

# ['Boost.Convert] shall provide a mechanism and an interface that take a value of type ['TypeIn] and yield a value of type ['TypeOut] using an algorithm of type ['Converter];
# ['Boost.Convert] shall provide a mechanism and an interface to indicate success or failure of the requested conversion;
# ['Boost.Convert] shall provide fully-functional interfaces for two different program flows where
    # error-processing is orthogonal to the normal program flow (exception-throwing interface);
    # normal and error-processing flows are part of the same program flow (non-throwing interface);
# The throwing interface shall return the result of successful conversion or shall throw an exception;
# The non-throwing interface shall return the result and/or some indication of conversion success or failure;
    # the result of conversion shall only be available when conversion succeeds;
    # when conversion fails, an optional fallback value shall be returned instead if supplied;
    # in the case of failure an attempt to retrieve the result (with no fallback provided) shall result in an exception thrown;
# Converters shall be independent of and shall not rely on the ['Boost.Convert] infrastructure.

[endsect]

[section Public/User Interface]

On numerous occasions it was noted that converters might be deployed directly. What such deployment would be lacking and what the single `boost::convert()` user interface provides is ['uniform] deployment and ['consistent behavior]. One single interface advertises and enforces a certain "contract" between the user (service consumer) and ['varying] conversion facilities (service provider). Working off such a "contract" allows

* for easier management of parallel development of the components meant to interact or rely on each other; 
* to adjust to requirement changes without major existing-code disruption (that includes major re-writes, major re-testing, etc.);
* easier deployment in generic code.

[section Converter Pluggability]
[endsect]
[section Signature]

The following converter signatures have been considered:

 bool operator()(TypeIn const&, TypeOut&); //#1
 void operator()(TypeIn const&, boost::optional<TypeOut>&); //#2
 boost::optional<TypeOut> operator()(TypeIn const&); //#3

On the design level the signature #1 has the advantage of providing the best ['separation of concerns]. It leaves the respective converter only with one task -- the actual task of conversion. In practice though that can lead to inefficiencies. Namely, given an instance of `TypeOut` type is supplied from outside, a storage for that instance needs to be allocated and, most importantly, that instance needs to be initialized. That initialization phase (which can be expensive) is a clear overhead as, if the conversion operation succeeds, the initial value is overridden with the actual result, if it fails, then the `TypeOut` instance of no use anyway.

The signature #2 avoids the initialization overhead. The storage for `TypeOut` is still allocated outside but it is not initialized. It is now converter's responsibility to know ['how] to initialize the `TypeOut` instance and to actually initialize it ['when] needed. In practice it usually easier than it sounds. For example,

 void operator()(char const* value_in, boost::optional<int>& result_out) const
 {
    char const* str_end = value_in + strlen(value_in);
    char*       cnv_end = 0;
    long int     result = ::strtol(value_in, &cnv_end, base_);

    if (INT_MIN <= result && result <= INT_MAX && cnv_end == str_end)
        result_out = int(result);
 }

The signature #3 has been briefly considered as aesthetically advantageous and more idiomatic. Unfortunately, it lacked automatic deduction of the `TypeOut` which, consequently, had to be specified explicitly. For different types of supported converters (class-based, plain old functions, lambdas) that complicated considerably the implementation of the ['Boost.Convert] infrastructure and restricted implementation of the respective converters. 

[endsect]
[section Converter-parameter-related considerations (explicit, default, globally-set, others)]
[endsect]
[section The Perceived Potential Complexity of the Interface]

The interface might be perceived as complex due to it trying to cater for different process flows and wide variety of deployment patterns. 

[endsect]
[endsect]

[section Converter Signature]
[endsect]
[endsect]

