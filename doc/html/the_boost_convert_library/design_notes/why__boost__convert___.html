<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Why boost::convert()</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;The Boost Convert Library 2.0">
<link rel="up" href="../design_notes.html" title="Design Notes">
<link rel="prev" href="../design_notes.html" title="Design Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../design_notes.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../design_notes.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="the_boost_convert_library.design_notes.why__boost__convert___"></a><a class="link" href="why__boost__convert___.html" title="Why boost::convert()">Why
      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">convert</span><span class="special">()</span></code></a>
</h3></div></div></div>
<p>
        It does not take long to realize that <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">convert</span><span class="special">()</span></code> by itself does very little. The respective
        converter -- the <span class="emphasis"><em>worker</em></span> component -- provides the actual
        functionality and even a somewhat useable interface that can be deployed
        directly (if one is determined to do so). I readily concede that on the one-man-project
        level the existence of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">convert</span><span class="special">()</span></code> can be hardly justified.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">convert</span><span class="special">()</span></code>
        is the <span class="emphasis"><em>manager</em></span> component and the benefits of deploying
        varying conversion facilities via one consistent interface become clearer
        on a larger industrial level of software development.
      </p>
<p>
        The purpose of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">convert</span><span class="special">()</span></code>
        is to formalize, advertize and enforce a <span class="emphasis"><em>contract</em></span> between
        the user (service consumer) and the developer (service provider).
      </p>
<p>
        That ultimately minimizes dependency of the application-domain (user) code
        on any particular infrastructure (conversion) API. New converters can be
        introduced and deployed later in the development cycle, with minimal or no
        impact on the existing code base as long as those converters conform to that
        specified contract.
      </p>
<p>
        Based on that contract the consumer knows what to expect and the provider
        knows what to provide <span class="bold"><strong>without consumer-provider interaction</strong></span>.
        In practical terms it is that every time I browse somebody else's code and
        see the interface, I immediately know what it does without reading the docs,
        learning new api, etc. In real life, when one is reading (trying to fix)
        somebody else's code the "reading the docs, learning new api" seems
        like a considerable diversion and often does not happen. So, the understanding
        of the code quickly turns into a guessing game. So, productivity is no more.
      </p>
<p>
        More so, in my view there is no even Convert "library". :-) I see
        my proposal as a conversion/transformation <span class="bold"><strong>framework</strong></span>.
        The difference between a library and a framework (in my view and in this
        particular case, anyway) is that the latter is merely the guidelines how
        to be able to develop code <span class="bold"><strong>later</strong></span> that is
        to be deployed in and without disrupting the old/existing code. That's what
        convert::from API facade does.
      </p>
<pre class="programlisting"><span class="identifier">That</span> <span class="identifier">allows</span> <span class="identifier">the</span> <span class="identifier">user</span> <span class="identifier">to</span> <span class="identifier">write</span> <span class="identifier">his</span> <span class="identifier">domain</span><span class="special">-</span><span class="identifier">specific</span> <span class="identifier">code</span>
</pre>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            now* and to plug some converter later (when it becomes available) or
            to replace one converter with another (if/when the requirements change)
            without major disruption of the existing code-base.
          </li></ul></div>
<p>
        As you correctly pointed out one-particular-converter functionality can be
        called directly rather than via "meaningless" convert::from.
      </p>
<p>
        The existence of Convert API facade is more for the purposes of <span class="bold"><strong>managing</strong></span> a large development which includes <span class="bold"><strong>simultaneously</strong></span> writing components which are meant
        to interact or rely on each other; adjusting to requirement changes without
        major existing code disruption (that includes major re-writes, major re-testing,
        etc.).
      </p>
<p>
        Yes, I understand your reasoning. I personally find the pluggability quality
        to be quite important.
      </p>
<p>
        First, from the first submission review it was clear to me that not everyone
        was interested in the std::sstream-based functionality and prepared to accept
        relative slowness of std::sstream. The pluggability addresses that issue
        with minimal effort and makes the library useful for much wider programming
        community.
      </p>
<p>
        Secondly, the separation of the API/facade from the actual converter -- the
        pluggability -- allows to write and deploy new/better/domain-specific converters
        easily -- as long as those converters conform to the API-imposed contract.
        The difference in "plugging a new converter" vs "replacing
        an existing directly-used converter with a new converter" is considerable
        in a large-scale development as the former only replaces a pluggable component
        (leaving the "plumbing" intact) and the latter may create a lot
        of ripples in the related code. An every-day example might be unplugging
        and replacing an electrical device. Clearly, with no pluggability replacing
        such a device (directly connected to your house wiring) might be quite a
        hassle. Yes, on one-person-writing-new-code level that pluggability looks
        like a hassle. My argument is that on the large-code-base, maintenance, changed-requirements
        phase pluggability is the only sane way to manage that change.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2009-2014 Vladimir Batov<p>
        Distributed under the Boost Software License, Version 1.0. See copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>.
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../design_notes.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../design_notes.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
</body>
</html>
