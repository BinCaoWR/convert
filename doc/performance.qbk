[section Performance]

The performance of ['Boost.Convert] depends entirely on the perfomance of the converter deployed. The previously mentioned converters have been tested as part of the ['Boost.Convert] framework (see ['test/performance.cpp]). The C++11 family of `std::to_string()`, `std::stoi()`, etc. were not tested due to unavailability.

Performance was tested for string conversions to the `int` type and to a user-defined type. On a 64-bit 12.04 Ubuntu box (compiled with gcc 4.6.3) tests produced the following results:

 str-to-int: spirit/strtol/scanf/lcast/sstream=2.06/6.84/26.59/10.94/26.26 seconds.
 int-to-str: spirit/ltostr/prntf/lcast/sstream=NA/125.56/176.23/107.59/208.09 seconds.
 str-to-user-type: lcast/sstream=3.75/1.91 seconds.
 user-type-to-str: lcast/sstream=5.60/1.33 seconds.

For user-defined types two converters -- `boost::lexical_cast`-based and `std::stringstream`-based -- were tested. Both converters provide ['string-to-type] and ['type-to-string] conversions; both deploy the same -- `std::sstream` -- conversion engine and I suspect both share the same noble goal -- to provide a uniform conversion interface and an extendible conversion framework where new types can be plugged in to the framework via:

 std::istream& operator>>(std::istream&, TypeOut&);
 std::ostream& operator<<(std::ostream&, TypeIn const&);

Unfortunately that comes at a price as `std::sstream`-based conversions of the basic (`int`, etc.) types are comparatively slow. Consequently, for basic types `boost::lexical_cast` implementation has been optimized to avoid `std::sstream`. ['Boost.Convert] addresses that "optimization" need via pluggable converters. Consequently, if speed is your primary objective and your needs do not go beyond basic types, then deploying ['Spirit], `std::to_string/std::stoi`, `strtol`, `printf/scanf`, `boost::lexical_cast` (directly or via the ['Boost.Convert] framework) might be an option to explore. 

For user-defined types it appears to be quite a different story with the `std::stringstream`-based converter consistently outperforming `boost::lexical_cast` in the tests. These results probably reflect different underlying designs.

The standard ['Boost.Convert] usage pattern is to create a converter or converters once and then re-use them. In turn, `boost::lexical_cast` also deploys the `std::sstream` engine for user-defined types. However, due to its design `boost::lexical_cast` creates and then destroys an instance of a stream type every time the function is called. The [@http://www.boost.org/doc/libs/1_55_0/doc/html/boost_lexical_cast/performance.html `boost::lexical_cast` performance] table indicates that the "std::stringstream with construction" operation is considerably more expensive compared to "std::stringstream without construction".

Based on the performance data I tend to conclude that, given type-safety and benefits provided by the ['Boost.Convert] framework, it (with appropriate converters) should probably be the first choice for conversion-related tasks.

[h2 ['Boost.Convert] Performance Overhead]

['Boost.Convert] framework adds an additional layer of indirection and some ['Boost.Convert] converters are wrappers around actual raw conversion facilities such as `strtol()`, `boost::lexical_cast`,  `boost::spirit`, etc. Consequently, legitimate are concerns about performance overhead introduced by the framework as opposed to deploying mentioned conversion facilities directly.

To test that [funcref test::performance::spirit_framework test::performance::spirit_framework] code has been borrowed and adapted from the Spirit optimization framework (see $BOOST_ROOT/libs/spirit/optimization/qi/int_parser.cpp). Performance tests were

# compiled using gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3;
# with full optimization ```g++ -O3 test/*.cpp example/*.cpp -Iinclude -I../boost_1_55_0 -lrt```
# on Ubuntu 12.04 (Linux 3.2.0-57-generic #87-Ubuntu SMP x86_64 GNU/Linux);
# run against the input of randomly generated 18 numeric strings (9 positive and 9 negative numbers with the number of digits from 1 to 9);
# run for 
    * `boost::lexical_cast`
    * `boost::lexical_cast`-based converter
    * `strtol()`
    * `strtol()`-based converter
    * `boost::spirit::qi::parse` parser
    * `boost::spirit::qi::parse`-based converter.

The purpose of this particular test was to deploy the same functionality directly and as part of the ['Boost.Convert]. Results are shown below for several consequtive runs of the `test_convert` program:

 Testing: 7,-8,13,-89,753,-670,7671,-1905,45436,-13998,573220,-188715,7527646,-1173621,95095988,-23161933,930008666,-852473336
 raw_lxcast_str_to_int_test: 1.0823377580 [s]
 cnv_lxcast_str_to_int_test: 1.1032241400 [s]
 raw_strtol_str_to_int_test: 0.6941694690 [s]
 cnv_strtol_str_to_int_test: 0.7003099920 [s]
 raw_spirit_str_to_int_test: 0.2791614670 [s]
 cnv_spirit_str_to_int_test: 0.2853485740 [s]

 Testing: 2,-5,95,-76,251,-139,5201,-9062,73362,-75915,984138,-163058,5301562,-6099471,44139215,-66342869,472999835,-944425688
 raw_lxcast_str_to_int_test: 1.1507759000 [s]
 cnv_lxcast_str_to_int_test: 1.1809066170 [s]
 raw_strtol_str_to_int_test: 0.6825586860 [s]
 cnv_strtol_str_to_int_test: 0.7065548380 [s]
 raw_spirit_str_to_int_test: 0.2794743890 [s]
 cnv_spirit_str_to_int_test: 0.2881680850 [s]

 Testing: 8,-3,27,-96,534,-557,3666,-2616,74990,-49153,790361,-656663,1499238,-7220122,73338528,-30197954,990405980,-912554300
 raw_lxcast_str_to_int_test: 1.1296698930 [s]
 cnv_lxcast_str_to_int_test: 1.1872108850 [s]
 raw_strtol_str_to_int_test: 0.6948299650 [s]
 cnv_strtol_str_to_int_test: 0.6976610260 [s]
 raw_spirit_str_to_int_test: 0.2720586660 [s]
 cnv_spirit_str_to_int_test: 0.2867466020 [s]

 Testing: 7,-4,88,-29,330,-179,4087,-7338,52740,-63806,829806,-829998,4089882,-4877638,56854373,-19034155,646856901,-979329889
 raw_lxcast_str_to_int_test: 1.1702910200 [s]
 cnv_lxcast_str_to_int_test: 1.1962990700 [s]
 raw_strtol_str_to_int_test: 0.7284593480 [s]
 cnv_strtol_str_to_int_test: 0.7476771280 [s]
 raw_spirit_str_to_int_test: 0.2989873150 [s]
 cnv_spirit_str_to_int_test: 0.3120227090 [s]

The results report up to five percent overhead (depending on the parser) of the ['Boost.Convert] framework. 

Obvously, the results are driven by the deployed compiler optimization capabilities and the hardware and are likely be different with a different compiler or a different version of the same compiler. For example, compiled with gcc-4.8.2 on 32-bit Ubuntu 14.04 the same test program produced:

 Testing: 3,-3,69,-85,333,-308,5199,-8718,63246,-11449,403616,-461493,8143020,-7167525,76245261,-97796055,496749962,-231859811
 raw_lxcast_str_to_int_test: 10.5022676440 [s]
 cnv_lxcast_str_to_int_test: 10.4914070410 [s]
 raw_strtol_str_to_int_test: 4.6645884930 [s]
 cnv_strtol_str_to_int_test: 4.5271582360 [s]
 raw_spirit_str_to_int_test: 2.0830079010 [s]
 cnv_spirit_str_to_int_test: 2.0799894250 [s]

 Testing: 6,-5,91,-93,195,-242,4404,-8261,28994,-97687,617025,-176081,6875359,-8879866,76203813,-85062763,931984407,-377353317
 raw_lxcast_str_to_int_test: 10.3305214320 [s]
 cnv_lxcast_str_to_int_test: 10.3119178060 [s]
 raw_strtol_str_to_int_test: 4.6692997760 [s]
 cnv_strtol_str_to_int_test: 4.5556425890 [s]
 raw_spirit_str_to_int_test: 2.0824675450 [s]
 cnv_spirit_str_to_int_test: 2.0794554230 [s]

That is, according to the results, conversions deployed through ['Boost.Convert] framework performed actually "better". Alternative tests indicated that ['Boost.Convert] overhead was well within the 1% margin of error as consequtive runs showed negative and positive performance differences:

 str-to-int: spirit raw/cnv=17.01/17.11 seconds (-0.59%).
 str-to-int: spirit raw/cnv=17.01/17.11 seconds (-0.59%).
 str-to-int: spirit raw/cnv=17.01/17.12 seconds (-0.65%).
 str-to-int: spirit raw/cnv=17.01/17.12 seconds (-0.65%).
 str-to-int: spirit raw/cnv=17.02/17.10 seconds (-0.47%).
 str-to-int: lxcast raw/cnv=98.14/98.42 seconds (-0.29%).
 str-to-int: lxcast raw/cnv=98.25/98.51 seconds (-0.26%).
 str-to-int: lxcast raw/cnv=98.46/98.72 seconds (-0.26%).
 str-to-int: lxcast raw/cnv=98.73/98.95 seconds (-0.22%).
 str-to-int: lxcast raw/cnv=98.70/98.76 seconds (-0.06%).
 str-to-int: spirit raw/cnv=17.47/17.45 seconds (0.11%).
 str-to-int: spirit raw/cnv=17.47/17.44 seconds (0.17%).
 str-to-int: spirit raw/cnv=17.47/17.44 seconds (0.17%).
 str-to-int: spirit raw/cnv=17.49/17.50 seconds (-0.06%).
 str-to-int: spirit raw/cnv=17.45/17.43 seconds (0.11%).
 str-to-int: lxcast raw/cnv=98.96/99.53 seconds (-0.58%).
 str-to-int: lxcast raw/cnv=99.12/99.52 seconds (-0.40%).
 str-to-int: lxcast raw/cnv=99.11/99.49 seconds (-0.38%).
 str-to-int: lxcast raw/cnv=99.09/99.50 seconds (-0.41%).
 str-to-int: lxcast raw/cnv=99.12/99.50 seconds (-0.38%)

That indicates that ['Boost.Convert] introduces from small to negligibly small performance overhead if any at all. 

[endsect]
