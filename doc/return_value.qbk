[/
  Copyright (c) Vladimir Batov 2009-2014
  Distributed under the Boost Software License, Version 1.0.
  See copy at http://www.boost.org/LICENSE_1_0.txt.
]

[section:return_value Return Value]

As it was indicated in the previous section `boost::optional` is the actual type returned by

 boost::optional<TypeOut> boost::convert(TypeIn const&, Converter const&);

The signature is ['functionally-complete] and is the most efficient in deploying the underlying converter.
That said, the following alternative interface but might be potentially better suitable
for certain deployment scenarios (or due to personal preferences):

 Out convert(In const&, Converter const&, Out const& fallback_value);
 Out convert(In const&, Converter const&, Functor const& fallback_functor);
 Out convert(In const&, Converter const&, boost::throw_on_failure);

It still provides full support for various program flows and various degrees of conversion-failure detection
and processing and can be deployed in a similar fashion as follows:

[getting_serious_example5]
[getting_serious_example7]

[note One might expect to see the following signature instead:

[^TypeOut boost::convert(TypeIn const&, Converter const&);]

(somewhat similar to what `boost::lexical_cast` does).
This signature is deceptively simple and, in reality (like `boost::lexical_cast`), it can only handle one scenario:
throwing an exception if conversion fails.
Consequently, in commercial software where process flows vary and reliability and operational continuity are important,
that limitation often has to be compensated by a considerable amount of additional code (like try/catch blocks, etc.).

On the other hand, the `boost::convert` signatures (although more verbose)
provide full support for various program flows, unambigous behavior and readability.
]

On the other hand, the `boost::convert` signatures (although more verbose) provide full support for various program flows,
are behaviorally unambiguous and readable.]

[endsect] [/section Return Value]




