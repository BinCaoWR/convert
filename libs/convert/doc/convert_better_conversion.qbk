[section:convert_better_conv Better Conversion-Failure Check With convert<>::result]

 int i2 = convert<int>::from("not an int", -1, cnv).value(); // after the call i2 = -1

 if (i2 == -1) failed to convert

Checking the return value as above is sufficiently straight-forward. Clearly, it is not always entirely correct as -1 might be returned due to a conversion failure and as the conversion result for the supplied "-1" string. The user needs to be aware of that non-determinism and a limitation of this basic interface. Still, such deployment might be adequate if there are "spare" values outside the valid range to indicate conversion failures (say, INT_MAX for integers) without introducing the above-mentioned behavioral non-determinism. More so, it might be not that uncommon for applications to ignore conversion failures altogether and to proceed with the supplied default/fallback value.

Applications outside of the mentioned categories still require a conversion-failure condition reliably detected and processed accordingly. The ['boost::lexical_cast] answer to the problem is to throw on failure and ['boost::convert] supports that behavior: 

 try
 {
     int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
     int i2 = boost::convert<int>(str, cnv); // Throws if the conversion fails
     ...
 }
 catch (...)
 {
     Conversion failed
 }

However, throwing an exception might not always be the desirable behavior (not to mention the awkwardness and slowness of the ['try/catch] interface which might not be exactly fitting). 

More so, some classes might fail to meet that requirement for the Target type to be /DefaultConstructible/. The following /direction/ class is one such example. It has only two (/direction::up/ and /direction::dn/) states available (i.e. no "spare" values to indicate conversion failure) and is not /DefaultConstructible/:

 struct direction
 {
     enum value_type { up, dn };
     direction(value_type value) : value_(value) {}
     private: value_type value_;
 };

For such a class the call below will not compile (due to the /DefaultConstructible/ Target type requirement):

 direction dir = convert<direction>::from(str);  // Does not compile

More so, the following is no good either as it does not provide a reliable detection of a conversion failure:

 direction dir = convert<direction>::from(str, direction::up); 
 
 if (dir == up_dir) ... // Was it a failure or a successful "up" conversion?

For situations like that the library provides the following interface:

 convert<direction>::result res = convert<direction>::from(str, up_dir); 
 if (res) conversion succeeded
 if (!res) conversion failed
 direction dir = res.value(); // Retrieve the conversion result

The /convert::result/ class has an implicit safe-bool conversion operator that allows to check the success of the conversion. The actual result of the conversion is retrieved with /convert::result::value()/.

That same /convert::result/ could be deployed to work around the throwing behavior of the /lexical_cast/-like interface:

 // This call does not throw.
 convert<int>::result res = convert<int>::from("not an int"); 
 // An attempt to retrieve a failed-conversion value will throw.
 int i1 = res.value();
 // Check the success first and retrieve the value if available.
 int i2 = res ? res.value() : -1;

[endsect]
