[section:convert_better_conv Getting Serious]

 int i2 = convert<int>::from("not an int", -1, cnv).value(); // after the call i2 = -1

 if (i2 == -1) failed to convert

Checking the return value as above is sufficiently straightforward. Clearly, it is not always entirely correct as -1 might be returned due to a conversion failure and as the conversion result for the supplied "-1" string. The user needs to be aware of that non-determinism and the limitation of this basic interface. 

Still, with a carefully chosen fallback value such deployment might be adequate when there are "spare" values outside the valid range to indicate conversion failures (say, INT_MAX for integers) without introducing the above-mentioned behavioral non-determinism. More so, it might be not that uncommon for applications to ignore conversion failures altogether and to proceed with the supplied default/fallback value.

Applications outside these mentioned categories still require a conversion-failure condition reliably detected and processed accordingly. The ['boost::lexical_cast]'s answer to the problem is to throw on failure and ['boost::convert] supports that behavior as well: 

 try
 {
     int i1 = boost::lexical_cast<int>(str); // Throws if the conversion fails
     int i2 = boost::convert<int>(str, cnv).value(); // Throws if the conversion fails
     ...
 }
 catch (...)
 {
     Conversion failed
 }

However, to better cater for the application's processing flow ['boost::convert] adds the flexibility of 

* delaying the moment when the conversion-failure exception is thrown or 
* avoiding the excepion altogether. 

 convert<int>result r1 = boost::convert<int>(str1, cnv); // Does not throw on conversion failure
 convert<int>result r2 = boost::convert<int>(str2, cnv); // Does not throw on conversion failure

 int i1 = r1 ? r1.value() : some-other-value; // Safe to retrieve the result
 int i2 = r2 ? r2.value() : some-other-value; // Safe to retrieve the result

 try
 {
     int i1 = r1.value(); // Will throw if conversion failed
     int i2 = r2.value(); // Will throw if conversion failed
 }
 catch (...)
 {
     Conversion failed
 }

Here ['convert<T>::result] comes to the fore as it is the actual type being returned by ['convert<T>::from]. As  ['boost::lexical_cast] does, ['convert<T>::result] undersores the fact that the conversion request is only a ['request] which may succeed but is also may fail. However, by design ['boost::lexical_cast] processes failure in a somewhat harsh and non-negociable manner.  ['convert<T>::result] chooses a softer approach and leaves the decision to the user. In my personal experience it is overwhelmingly avoiding exceptions altogether with something like:

 if (r1)
 {
     int i1 = r1.value(); // Safe to retrieve the result
     ...proceed
 }

Or

 convert<int>result r1 = boost::convert<int>(str1, 5, cnv); // Does not throw on conversion failure
 convert<int>result r2 = boost::convert<int>(str2, 6, cnv); // Does not throw on conversion failure

 if (!r1) log("str1 conversion failed");
 if (!r2) log("str2 conversion failed");

 int i1 = r1.value(); // Does not throw
 int i2 = r2.value(); // Does not throw

 ...proceed

a

a

a

a

a

a

a

a

a

a

a
a


More so, some classes might fail to meet that requirement for the Target type to be /DefaultConstructible/. The following /direction/ class is one such example. It has only two (/direction::up/ and /direction::dn/) states available (i.e. no "spare" values to indicate conversion failure) and is not /DefaultConstructible/:

 struct direction
 {
     enum value_type { up, dn };
     direction(value_type value) : value_(value) {}
     private: value_type value_;
 };

For such a class the call below will not compile (due to the /DefaultConstructible/ Target type requirement):

 direction dir = convert<direction>::from(str);  // Does not compile

More so, the following is no good either as it does not provide a reliable detection of a conversion failure:

 direction dir = convert<direction>::from(str, direction::up); 
 
 if (dir == up_dir) ... // Was it a failure or a successful "up" conversion?

For situations like that the library provides the following interface:

 convert<direction>::result res = convert<direction>::from(str, up_dir); 
 if (res) conversion succeeded
 if (!res) conversion failed
 direction dir = res.value(); // Retrieve the conversion result

The /convert::result/ class has an implicit safe-bool conversion operator that allows to check the success of the conversion. The actual result of the conversion is retrieved with /convert::result::value()/.

That same /convert::result/ could be deployed to work around the throwing behavior of the /lexical_cast/-like interface:

 // This call does not throw.
 convert<int>::result res = convert<int>::from("not an int"); 
 // An attempt to retrieve a failed-conversion value will throw.
 int i1 = res.value();
 // Check the success first and retrieve the value if available.
 int i2 = res ? res.value() : -1;

[endsect]
