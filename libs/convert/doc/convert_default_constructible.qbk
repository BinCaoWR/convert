[section:convert_default_constructible The ['Default Constructible] Type Requirement]

In order for a type to be integrated into the ['boost::lexical_cast] framework that type needs to be ['Default Constructible]. That requirement is quite unfortunate because 

* potentially influences\/distorts the design of the user types; 
* it limits the number of types manageable by ['boost::lexical_cast] and 
* it is imposed by the implementation.

Deeply in the bowels in the implementation a temporary-storage instance of the Target type is to be created and then populated with the conversion result. The ['boost::lexical_cast] implementation chooses the default constructor to create such an instance. For more details see __ref_1__. 

That is also the default requirement of ['boost::convert]. 

A well-designed type (in my opinion, anyway) should only have meaningful and unambiguous constructors... and the default constructor is not necessarily one of them. Consider the following ['direction] type as one such example. The type has only two meaningful states and is not ['Default Constructible]:

 struct direction
 {
     enum value_type { up, dn };
     direction(value_type value) : value_(value) {}
     private: value_type value_;
 };

For such a type the call below will not compile (due to the ['Default Constructible] requirement):

 direction dir1 = lexical_cast<direction>(str); // Does not compile
 direction dir2 = convert<direction>::from(str).value(); // Does not compile

However, with little help from the user ['boost::convert] will be able to handle such a type. What ['boost::convert] needs is the instructions ['how] to create that mentioned temporary-storage instance:

 namespace boost
 {
    template<> inline direction convert<direction>::create_storage() 
    { 
        return direction(direction::up); 
    }
 }

 direction dir2 = convert<direction>::from(str).value(); // Compiles

It is not difficult to guess what the default implementation of ['boost::convert<>::create_storage()] is:

 namespace boost
 {
    template<class TypeOut> 
    TypeOut 
    convert<TypeOut>::create_storage() 
    { 
        return TypeOut(); 
    }
 }
 
[endsect]
