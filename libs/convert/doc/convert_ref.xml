<?xml version="1.0" standalone="yes"?>
<library-reference id="convert_reference"><title>Convert Reference</title><header name="boost/convert/api.hpp"><namespace name="boost"><struct name="convert"><template>
      <template-type-parameter name="TypeOut"/>
    </template><struct name="algorithm_helper"><template>
      <template-type-parameter name="TypeIn"/>
      <template-type-parameter name="Converter"/>
    </template><typedef name="this_type"><type><classname>algorithm_helper</classname></type></typedef><data-member name="converter_"><type>Converter const *</type></data-member><data-member name="fallback_"><type>optional_out_type</type></data-member><data-member name="throw_"><type>status_type</type></data-member><method-group name="public member functions"><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>parameter::aux::tagged_argument&lt; conversion::parameter::type::fallback, Arg &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>parameter::aux::tagged_argument&lt; conversion::parameter::type::throw_on_failure, Arg &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>TypeOut</type><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter></method></method-group><constructor><parameter name="cnv"><paramtype>Converter const &amp;</paramtype></parameter></constructor></struct><struct name="result"><typedef name="this_type"><type><classname>result</classname></type></typedef><typedef name="safebool"><type><classname>boost::safebool</classname>&lt; <classname>result</classname> &gt;</type></typedef><method-group name="public member functions"><method name="operator!" cv="const"><type>bool</type></method><method name="conversion-operator" cv="const"><type>typename safebool::type</type></method><method name="value" cv="const"><type>out_type const &amp;</type></method><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>parameter::aux::tagged_argument&lt; conversion::parameter::type::throw_on_failure, Arg &gt; const &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="v"><paramtype>out_type const &amp;</paramtype></parameter><parameter name="s"><paramtype>status</paramtype></parameter></constructor></struct><typedef name="this_type"><type><classname>boost::convert</classname>&lt; TypeOut &gt;</type></typedef><typedef name="out_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="optional_out_type"><type>boost::optional&lt; out_type &gt;</type></typedef><typedef name="result_type"><type><classname>this_type::result</classname></type></typedef><typedef name="status_type"><type>result_type::status</type></typedef><method-group name="public static functions"><method name="from" cv=""><type>static <classname>result_type</classname></type><template>
          <template-type-parameter name="TypeIn"/>
          <template-type-parameter name="Converter"/>
        </template><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter><parameter name="converter"><paramtype>Converter const &amp;</paramtype></parameter></method><method name="from" cv=""><type>static <classname>result_type</classname></type><template>
          <template-type-parameter name="TypeIn"/>
          <template-type-parameter name="FallbackType"/>
          <template-type-parameter name="Converter"/>
        </template><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter><parameter name="fallback"><paramtype>FallbackType const &amp;</paramtype></parameter><parameter name="converter"><paramtype>Converter const &amp;</paramtype></parameter></method><method name="from" cv=""><type>static <classname>algorithm_helper</classname>&lt; TypeIn, Converter &gt;</type><template>
          <template-type-parameter name="TypeIn"/>
          <template-type-parameter name="Converter"/>
        </template><parameter name="cnv"><paramtype>Converter const &amp;</paramtype></parameter></method></method-group></struct></namespace></header><header name="boost/convert/boost_parameter_ext.hpp"><namespace name="boost"><namespace name="parameter"><struct name="parameter_type"><template>
      <template-type-parameter name="ArgsT"/>
      <template-type-parameter name="KeywordTagT"/>
    </template><typedef name="type"><type>void</type></typedef></struct><struct-specialization name="parameter_type"><template>
      <template-type-parameter name="ArgT"/>
      <template-type-parameter name="KeywordTagT"/>
    </template><specialization><template-arg>aux::tagged_argument&lt; KeywordTagT</template-arg><template-arg>ArgT &gt;</template-arg><template-arg>KeywordTagT</template-arg></specialization><typedef name="type"><type>aux::tagged_argument&lt; KeywordTagT, ArgT &gt;::value_type</type></typedef></struct-specialization><struct-specialization name="parameter_type"><template>
      <template-type-parameter name="KeywordTagT1"/>
      <template-type-parameter name="ArgT"/>
      <template-type-parameter name="KeywordTagT2"/>
    </template><specialization><template-arg>aux::tagged_argument&lt; KeywordTagT1</template-arg><template-arg>ArgT &gt;</template-arg><template-arg>KeywordTagT2</template-arg></specialization><typedef name="type"><type>void</type></typedef></struct-specialization><struct-specialization name="parameter_type"><template>
      <template-type-parameter name="ArgT"/>
      <template-type-parameter name="TailT"/>
      <template-type-parameter name="KeywordTagT"/>
    </template><specialization><template-arg>aux::arg_list&lt; aux::tagged_argument&lt; KeywordTagT</template-arg><template-arg>ArgT &gt;</template-arg><template-arg>TailT &gt;</template-arg><template-arg>KeywordTagT</template-arg></specialization><typedef name="type"><type>aux::tagged_argument&lt; KeywordTagT, ArgT &gt;::value_type</type></typedef></struct-specialization><struct-specialization name="parameter_type"><template>
      <template-type-parameter name="KeywordTagT1"/>
      <template-type-parameter name="ArgT"/>
      <template-type-parameter name="TailT"/>
      <template-type-parameter name="KeywordTagT2"/>
    </template><specialization><template-arg>aux::arg_list&lt; aux::tagged_argument&lt; KeywordTagT1</template-arg><template-arg>ArgT &gt;</template-arg><template-arg>TailT &gt;</template-arg><template-arg>KeywordTagT2</template-arg></specialization><inherit access="public">boost::parameter::parameter_type&lt; TailT, KeywordTagT2 &gt;</inherit></struct-specialization></namespace></namespace></header><header name="boost/convert/lexical_cast_converter.hpp"><namespace name="boost"><struct name="lexical_cast_based_converter"><method-group name="public member functions"><method name="convert" cv="const"><type>bool</type><template>
          <template-type-parameter name="TypeOut"/>
          <template-type-parameter name="TypeIn"/>
        </template><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter><parameter name="result_out"><paramtype>TypeOut &amp;</paramtype></parameter></method></method-group></struct></namespace></header><header name="boost/convert/parameters.hpp"><namespace name="boost"><namespace name="conversion"><namespace name="parameter"><function name="BOOST_PARAMETER_KEYWORD"><type/><parameter name=""><paramtype>type</paramtype></parameter><parameter name=""><paramtype>throw_on_failure</paramtype></parameter><purpose>Specify throw-on-failure behavior explicitly. </purpose></function><function name="BOOST_PARAMETER_KEYWORD"><type/><parameter name=""><paramtype>type</paramtype></parameter><parameter name=""><paramtype>locale</paramtype></parameter><purpose>Specify locale. </purpose></function><function name="BOOST_PARAMETER_KEYWORD"><type/><parameter name=""><paramtype>type</paramtype></parameter><parameter name=""><paramtype>fallback</paramtype></parameter><purpose>Provide fallback value. </purpose></function></namespace></namespace></namespace></header><header name="boost/convert/safebool.hpp"><namespace name="boost"><struct name="safebool"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Generalization of the Safe-Bool Technique. </purpose><description><para>An implicit conversion to bool (operator bool() const) is very much idiomatic and is often deployed in constructs like "if (foo)" and "if (!foo)" (with no explicit op!() defined). However, sadly, implementing "operator bool()" is *wrong* as that conversion kicks in far too often and unexpectedly. Like in "foo == 1", "foo+1", "1+foo" or potentially during lexical_cast&lt;string&gt;(foo) (if there are no op&gt;&gt;() and op&lt;&lt;() defined). Consequently, that "implicit
    conversion to bool" functionality has to be implemented in an indirect and somewhat awkward way via an implicit conversion to some other type. The best type for the purpose appears to be a pointer to a member function. For more see the chapter 7.7 in Alexandrescu's "Modern C++ Design" and the article at <ulink url="http://www.artima.com/cppsource/safebool.html">http://www.artima.com/cppsource/safebool.html</ulink> by Bjorn Karlsson.<sbr/>
<sbr/>
 Deployment: <programlisting> struct Foo
 { ...
     operator safebool&lt;Foo&gt;::type() const { return safebool&lt;Foo&gt;(condition); }
 };
 template&lt;class T&gt;
 struct Moo // for a template class
 { ...
     operator typename safebool&lt;Moo&gt;::type() const { return safebool&lt;Moo&gt;(condition); }
 };
 template&lt;class T&gt;
 struct Zoo // with convenience typedefs
 { ...
     typedef safebool&lt;Zoo&gt; safebool;
     typedef typename safebool::type safebool_type;

     operator safebool_type() const { return safebool(condition); }
 };
</programlisting> safebool needs to be a template to make the returned safebool&lt;Foo&gt;::type type unique. Without it different classes would return the same safebool::type type that would make possible relational operators between unrelated types. Like <programlisting>     struct Foo { operator safebool::type() const { return safebool(...); }};
     struct Moo { operator safebool::type() const { return safebool(...); }};
     Foo foo;
     Zoo zoo;
     if (foo == zoo) Valid (but wrong) comparison between unrelated types.
</programlisting> </para></description><typedef name="type"><type>void(safebool::*</type></typedef><method-group name="public member functions"><method name="conversion-operator" cv="const"><type>type</type></method></method-group><constructor specifiers="explicit"><parameter name="v"><paramtype>bool</paramtype></parameter></constructor><method-group name="private member functions"><method name="true_" cv="const"><type>void</type></method></method-group></struct></namespace></header><header name="boost/convert/sstream_converter.hpp"><namespace name="boost"><struct name="basic_stringstream_based_converter"><template>
      <template-type-parameter name="Char"/>
    </template><typedef name="char_type"><type>Char</type></typedef><typedef name="this_type"><type><classname>basic_stringstream_based_converter</classname></type></typedef><typedef name="stream_type"><type>std::basic_stringstream&lt; char_type &gt;</type></typedef><typedef name="manipulator_type"><type>std::ios_base &amp;(*</type></typedef><method-group name="public member functions"><method name="convert" cv=""><type>boost::optional&lt; TypeOut &gt;</type><template>
          <template-type-parameter name="TypeOut"/>
          <template-type-parameter name="TypeIn"/>
        </template><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter></method><method name="convert" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="StringOut"/>
          <template-type-parameter name="TypeIn"/>
        </template><parameter name="value_in"><paramtype>TypeIn const &amp;</paramtype></parameter><parameter name="result_out"><paramtype>StringOut &amp;</paramtype></parameter></method><method name="convert" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="TypeOut"/>
          <template-type-parameter name="StringIn"/>
        </template><parameter name="value_in"><paramtype>StringIn const &amp;</paramtype></parameter><parameter name="result_out"><paramtype>TypeOut &amp;</paramtype></parameter></method><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="locale"><paramtype>std::locale const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><parameter name="m"><paramtype>manipulator_type</paramtype></parameter></method><method name="operator()" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Manipulator"/>
        </template><parameter name="m"><paramtype>Manipulator</paramtype></parameter></method><method name="operator&gt;&gt;" cv=""><type><classname>this_type</classname> &amp;</type><template>
          <template-type-parameter name="Manipulator"/>
        </template><parameter name="m"><paramtype>Manipulator</paramtype></parameter></method></method-group><constructor/></struct><typedef name="cstringstream_based_converter"><type><classname>basic_stringstream_based_converter</classname>&lt; char &gt;</type></typedef><typedef name="wstringstream_based_converter"><type><classname>basic_stringstream_based_converter</classname>&lt; wchar_t &gt;</type></typedef></namespace></header><header name="boost/convert/string_sfinae.hpp"><para>Defines various string-related type checks </para><namespace name="boost"/></header><header name="boost/convert/workarounds.hpp"/></library-reference>
